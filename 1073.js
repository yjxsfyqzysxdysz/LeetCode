/**
 * 1073. 负二进制数相加
 *
 * 给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。
 * 数字以 数组形式 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，arr = [1,1,0,1] 表示数字 (-2)^3 + (-2)^2 + (-2)^0 = -3。数组形式 中的数字 arr 也同样不含前导零：即 arr == [0] 或 arr[0] == 1。
 * 返回相同表示形式的 arr1 和 arr2 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。
 *
 * 示例 1：
 * 输入：arr1 = [1,1,1,1,1], arr2 = [1,0,1]
 * 输出：[1,0,0,0,0]
 * 解释：arr1 表示 11，arr2 表示 5，输出表示 16 。
 *
 * 示例 2：
 * 输入：arr1 = [0], arr2 = [0]
 * 输出：[0]
 *
 * 示例 3：
 * 输入：arr1 = [0], arr2 = [1]
 * 输出：[1]
 *
 * 提示：
 * 1 <= arr1.length, arr2.length <= 1000
 * arr1[i] 和 arr2[i] 都是 0 或 1
 * arr1 和 arr2 都没有前导0
 */

/**
 * @param {number[]} arr1
 * @param {number[]} arr2
 * @return {number[]}
 */

/**
 * 00001 = (-2)^0                                     = 1                    = 1
 * 00010 = (-2)^1                                     = -2                   = -2
 * 00011 = (-2)^1 + (-2)^0                            = -2 + 1 = -1          = -1
 * 00100 = (-2)^2                                     = 4                    = 4
 * 00101 = (-2)^2 + (-2)^0                            = 4 + 1 = 5            = 5
 * 00110 = (-2)^2 + (-2)^1                            = 4 + -2 = 2           = 2
 * 00111 = (-2)^2 + (-2)^1 + (-2)^0                   = 4 + -2 + 1 = 3       = 3
 * 01000 = (-2)^3                                     = -8                   = -8
 * 01001 = (-2)^3 + (-2)^0                            = -8 + 1               = -7
 * 01010 = (-2)^3 + (-2)^1                            = -8 + -2              = -10
 * 01011 = (-2)^3 + (-2)^1 + (-2)^0                   = -8 + -2 + 1          = -9
 * 01100 = (-2)^3 + (-2)^2                            = -8 + 4               = -4
 * 01101 = (-2)^3 + (-2)^2 + (-2)^0                   = -8 + 4 + 1           = -3
 * 01110 = (-2)^3 + (-2)^2 + (-2)^1                   = -8 + 4 + -2          = -6
 * 01111 = (-2)^3 + (-2)^2 + (-2)^1 + (-2)^0          = -8 + 4 + -2 + 1      = -5
 * 10000 = (-2)^4                                     = 16                   = 16
 * 10001 = (-2)^4 + (-2)^0                            = 16 + 1               = 17
 * 10010 = (-2)^4 + (-2)^1                            = 16 + -2              = 14
 * 10011 = (-2)^4 + (-2)^1 + (-2)^0                   = 16 + -2 + 1          = 15
 * 10100 = (-2)^4 + (-2)^2                            = 16 + 4               = 20
 * 10101 = (-2)^4 + (-2)^2 + (-2)^0                   = 16 + 4 + 1           = 21
 * 10110 = (-2)^4 + (-2)^2 + (-2)^1                   = 16 + 4 + -2          = 18
 * 10111 = (-2)^4 + (-2)^2 + (-2)^1 + (-2)^0          = 16 + 4 + -2 + 1      = 19
 * 11000 = (-2)^4 + (-2)^3                            = 16 + -8              = 8
 * 11001 = (-2)^4 + (-2)^3 + (-2)^0                   = 16 + -8 + 1          = 9
 * 11010 = (-2)^4 + (-2)^3 + (-2)^1                   = 16 + -8 + -2         = 6
 * 11011 = (-2)^4 + (-2)^3 + (-2)^1 + (-2)^0          = 16 + -8 + -2 + 1     = 7
 * 11100 = (-2)^4 + (-2)^3 + (-2)^2                   = 16 + -8 + 4          = 12
 * 11101 = (-2)^4 + (-2)^3 + (-2)^2 + (-2)^0          = 16 + -8 + 4 + 1      = 13
 * 11110 = (-2)^4 + (-2)^3 + (-2)^2 + (-2)^1          = 16 + -8 + 4 + -2     = 10
 * 11111 = (-2)^4 + (-2)^3 + (-2)^2 + (-2)^1 + (-2)^0 = 16 + -8 + 4 + -2 + 1 = 11
 *
 * | 正 数 |    | 负 数  | 正 常 |
 * | 00001 |  1 | 00011 | 00001 |
 * | 00110 |  2 | 00010 | 00010 |
 * | 00111 |  3 | 01101 | 00011 |
 * | 00100 |  4 | 01100 | 00100 |
 * | 00101 |  5 | 01111 | 00101 |
 * | 11010 |  6 | 01110 | 00110 |
 * | 11011 |  7 | 01001 | 00111 |
 * | 11000 |  8 | 01000 | 01000 |
 * | 11001 |  9 | 01011 | 01001 |
 * | 11110 | 10 | 01010 | 01010 |
 */

var addNegabinary = function (arr1, arr2) {
  let i = arr1.length - 1,
    j = arr2.length - 1
  let carry = 0 // 范围 { -1, 0, 1 }
  const ans = []
  // -(-2)^i = (-2)^(i+1) + (-2)^i
  while (i >= 0 || j >= 0 || carry != 0) {
    let x = carry
    if (i >= 0) x += arr1[i]
    if (j >= 0) x += arr2[j]
    // x { 2, 3 }, carry = -1
    if (x >= 2) {
      ans.push(x - 2)
      carry = -1
    }
    // x { 0, 1 }, carry = 0
    else if (x >= 0) {
      ans.push(x)
      carry = 0
    }
    // x { -1 }, carry = 1
    else {
      ans.push(1)
      carry = 1
    }
    i--
    j--
  }
  while (ans.length > 1 && ans[ans.length - 1] === 0) ans.splice(ans.length - 1, 1)
  return ans.reverse()
}

console.log(addNegabinary([1, 1, 1, 1, 1], [1, 0, 1]))
console.log(addNegabinary([0], [0]))
console.log(addNegabinary([0], [1]))
console.log(addNegabinary([1], [1]))
