/**
 * 746. 使用最小花费爬楼梯
 *
 * 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
 * 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
 * 请你计算并返回达到楼梯顶部的最低花费。
 *
 * 示例 1：
 * 输入：cost = [10,15,20]
 * 输出：15
 * 解释：你将从下标为 1 的台阶开始。
 * - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
 * 总花费为 15 。
 *
 * 示例 2：
 * 输入：cost = [1,100,1,1,1,100,1,1,100,1]
 * 输出：6
 * 解释：你将从下标为 0 的台阶开始。
 * - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
 * - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
 * - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
 * - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
 * - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
 * - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
 * 总花费为 6 。
 *
 * 提示：
 * 2 <= cost.length <= 1000
 * 0 <= cost[i] <= 999
 */

/**
 * @param {number[]} cost
 * @return {number}
 */
// var minCostClimbingStairs = function (cost) {
//   // 贪心 不是最优解
//   let res = 0
//   for (let i = cost[0] < cost[1] ? 0 : 1; i < cost.length; ) {
//     res += cost[i]
//     if (cost[i + 1] < cost[i + 2]) {
//       i++
//     } else {
//       i += 2
//     }
//   }
//   return res
// }

var minCostClimbingStairs = function (cost) {
  // 动态规划
  /**
   * 穷举分析
   * * 自顶向上的穷举
   * * * [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
   * * * 当nums加入一个元素   1 时, []                              花费是 0
   * * * 当nums加入一个元素 100 时, []                              花费是 0
   * * * 当nums加入一个元素   1 时, [1]或者[100]                    花费是 1
   * * * 当nums加入一个元素   1 时, [1,1]或者[100]                  花费是 2
   * * * 当nums加入一个元素   1 时, [1,1]或者[1,1,1]                花费是 2
   * * * 当nums加入一个元素 100 时, [1,1,1]或者[1,1,1,1]            花费是 3
   * * * 当nums加入一个元素   1 时, [1,1,1]或者[1,1,1,100]          花费是 3
   * * * 当nums加入一个元素   1 时, [1,1,1,100]或者[1,1,1,1]        花费是 4
   * * * 当nums加入一个元素 100 时, [1,1,1,1,1]或者[1,1,1,1]        花费是 4
   * * * 当nums加入一个元素   1 时, [1,1,1,1,1]或者[1,1,1,1,100]    花费是 5
   * * * 当nums加入一个元素   * 时, [1,1,1,1,100]或者[1,1,1,1,1,1]  花费是 6
   * 确定边界
   * * 当nums数组小于 2 个元素时, 花费皆为 0, dp(0) = 0; dp(1) = 0;
   * * 当nums数组有 3 个元素时, dp(2) = Math.min(dp(0) + nums[0], dp(1) + nums[1])
   * 找规律,确定最优子结构
   * * 如果新加入一个元素 nums[i], 到达 i 的最小花费为 到达 (i - 1) + nums[i - 1] 或 (i - 2) + nums[i - 2] 的值
   * * 最优子结构
   * * i >= 2
   * * * dp(i) = Math.min(dp(i - 1) + nums[i - 1], dp(i - 2) + nums[i - 2])
   * 状态转移方程
   * * 最小花费 =dp[dp.length - 1]
   */
  const n = cost.length
  // dp[i] 表示达到下标 i 的最小花费。
  const dp = new Array(n + 1).fill(0)
  for (let i = 2; i <= n; i++) {
    dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
  }
  return dp.at(-1)
}

console.log(minCostClimbingStairs([10, 15, 20]))
console.log(minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]))
