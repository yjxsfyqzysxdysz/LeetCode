/**
 * 颠倒二进制位
 *
 * 颠倒给定的 32 位无符号整数的二进制位。
 * 提示：
 * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
 * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 *
 * 示例 1：
 * 输入：n = 00000010100101000001111010011100
 * 输出：964176192 (00111001011110000010100101000000)
 * 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
 *      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
 *
 * 示例 2：
 * 输入：n = 11111111111111111111111111111101
 * 输出：3221225471 (10111111111111111111111111111111)
 * 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
 *      因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
 *
 * 提示：
 * 输入是一个长度为 32 的二进制字符串
 */

/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
// var reverseBits = function (n) {
//   return parseInt(n.toString(2).padStart(32, '0').split('').reverse().join(''), 2)
// }

// 位运算分治
// var reverseBits = function (n) {
//   /**
//    * 若要翻转一个二进制串
//    * 可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。
//    * 由于左右两部分的计算方式是相似的
//    * 利用位掩码和位移运算，我们可以自底向上地完成这一分治流程
//    *
//    * 对于递归的最底层，我们需要交换所有奇偶位：
//    * 取出所有奇数位和偶数位；
//    * 将奇数位移到偶数位上，偶数位移到奇数位上。
//    * 类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶组上，偶数组移到奇数组上。以此类推。
//    */
//   const M1 = 0x55555555 // 01010101010101010101010101010101
//   const M2 = 0x33333333 // 00110011001100110011001100110011
//   const M4 = 0x0f0f0f0f // 00001111000011110000111100001111
//   const M8 = 0x00ff00ff // 00000000111111110000000011111111

//   n = ((n >>> 1) & M1) | ((n & M1) << 1)
//   n = ((n >>> 2) & M2) | ((n & M2) << 2)
//   n = ((n >>> 4) & M4) | ((n & M4) << 4)
//   n = ((n >>> 8) & M8) | ((n & M8) << 8)
//   return ((n >>> 16) | (n << 16)) >>> 0

//   // console.log(n.toString(2).padStart(32, '0')) // 原式
//   // console.log((n >>> 1).toString(2).padStart(32, '0')) // 向右移动一位，偶数位变奇数位
//   // console.log(((n >>> 1) & M1).toString(2).padStart(32, '0')) // 析出 new奇数位 为 1 的
//   // console.log((n & M1).toString(2).padStart(32, '0')) // 析出 old奇数位 为 1 的
//   // console.log(((n & M1) << 1).toString(2).padStart(32, '0')) // 向左移动一位，奇数位变偶数位
//   // console.log((((n >>> 1) & M1) | ((n & M1) << 1)).toString(2).padStart(32, '0')) // new奇数位 | new偶数位, 遇真则真
//   /**
//    * 00000010100101000001111010011100   n                                   原式
//    * 00000001010010100000111101001110   n >>> 1                             向右移动一位，偶数位变奇数位
//    * 00000001010000000000010101000100   (n >>> 1) & M1                      析出 new奇数位 为 1 的
//    * 00000000000101000001010000010100   n & M1                              析出 old奇数位 为 1 的
//    * 00000000001010000010100000101000   (n & M1) << 1                       向左移动一位，奇数位变偶数位
//    * 00000001011010000010110101101100   ((n >>> 1) & M1) | ((n & M1) << 1)  new奇数位 | new偶数位, 遇真则真 完成初次分治
//    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//    * * 00 00 00 01 01 00 00 00 00 00 01 01 01 00 01 00   (n >>> 1) & M1                       析出 new奇数位
//    * * 00 00 00 00 00 10 10 00 00 10 10 00 00 10 10 00   (n & M1) << 1                        析出 new偶数位
//    * * 00 00 00 01 01 10 10 00 00 10 11 01 01 10 11 00   ((n >>> 1) & M1) | ((n & M1) << 1)   new奇数位 new偶数位 按位与
//    * * 00 00 00 10 10 01 01 00 00 01 11 10 10 01 11 00   n                                    原式
//    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//    * 如此反复, 2位一翻转, 4位一翻转, 8位一翻转, 16位一翻转
//    */
// }

// 逐位颠倒
var reverseBits = function (n) {
  let rev = 0
  for (let i = 0; i < 32 && n > 0; ++i) {
    // 将最低位 按位与 获取(全真为真)
    // 并将其左移至 31-i 位 ([0,31]位)
    // rev 原值 与 新值 按位或(全假为假)
    rev |= (n & 1) << (31 - i)
    n >>>= 1 // 原式右移一位, 左端自动补0
  }
  /**
   * >>>
   * 将左操作数计算为无符号数
   * 其符号位变为 0，因此结果始终为非负数
   * 前缀补 1
   *
   * 当一个数进行无符号位移的时候，会舍弃掉正负号以及小数点后面的数字
   * 1.2 >>> 0  // 1
   * -2.3 >>> 0 // 4294967294
   * 9 >> 0     // 9
   * -9 >>> 0   // 4294967287
   * -9.2 >>> 0 // 4294967287
   * 如果不能转换成数字直接返回0
   * {} >>> 0   // 0
   */
  return rev >>> 0
}
// var reverseBits = function (n) {
//   let rev = ''
//   const nString = n.toString(2)
//   for (let i = nString.length - 1; i >= 0; i--) {
//     rev += nString[i]
//   }
//   return parseInt(rev.padEnd(32, '0'), 2)
// }

console.log(reverseBits(parseInt('10111111111111111111111111111111', 2)))
// console.log(reverseBits(parseInt('00000010100101000001111010011100', 2)))
// console.log(reverseBits(parseInt('11111111111111111111111111111101', 2)))
